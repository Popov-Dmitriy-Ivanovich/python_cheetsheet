# #TODO

match (дописать полностью когда появятся словари)??

regex

строки (done)

with as, in, not, (done)

file in/out

args?

date/time

# Функциональный  python

## Область видимости переменных

### Скрытие переменных

локальная переменная перекрывает глобальную (при ее изменении будет меняться локально созданный объект)  

### global

Если же мы хотим изменить в локальной функции глобальную переменную, а не определить локальную, то необходимо использовать ключевое слово `global`:  

```python
name = "Tom"  

def say_hi():  
    global  name  
    name = "Bob"        # изменяем значение глобальной переменной  
    print("Hello", name)  

say_hi()    # Hello Bob  
```

### nonlocal

Выражение `nonlocal` прикрепляет идентификатор к переменной из ближайщего окружающего контекста (за исключением глобального контекста). Обычно `nonlocal` применяется во вложенных функциях, когда надо прикрепить идентификатор за переменной или параметром окружающей внешней функции. Рассмотрим ситуацию, где это выражение может пригодиться:  

```python
def outer():  # внешняя функция
       n = 5
    def inner():    # вложенная функция
        n = 25 #создаваться новая переменная n, 
                #которая скроет переменную n из окружающей внешней
                # функции outer и получит значение 25
        print(n)
    inner()     # 25
    print(n)

outer()     # 5 
# 25    - inner
# 5     - outer
```

```python
def outer():  # внешняя функция
n = 5

    def inner():    # вложенная функция
        nonlocal n  # указываем, что n - это переменная из окружающей
                    # функции присваиваем значение 25 outer::n
        n = 25
        print(n)

    inner()     # 25
    print(n)


outer()
# 25 25
```

## Лямбда-выражения

Лямбда-выражения в языке Python представляют небольшие анонимные функции, которые определяются с помощью оператора `lambda`. Формальное определение лямбда-выражения:

```python
lambda [параметры] : инструкция
```

```python
    message = lambda: print("hello") 
    message() # output: hello
```

```python
sum = lambda a, b: a + b 
print(sum(4, 5))    # 9
```

`lambda`-выражения можно так же передавать в качестве параметров функции и (или) возвращать из функции (`return`)

## Замыкания

**<u>Замыкание</u>** (closure) представляет функцию, которая запоминает свое лексическое окружение даже в том случае, когда она выполняется вне своей области видимости.

Технически замыкание включает три компонента:

- внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные и параметры - лексическое окружение

- переменные и параметры (лексическое окружение), которые определены во внешней функции

- вложенная функция, которая использует переменные и параметры внешней функции

Для определения замыканий в Python применяются локальные функции:

```python
def outer():        # внешняя функция
    n = 5           # лексическое окружение - локальная переменная
    def inner():      # локальная функция
        nonlocal n
        n += 1        # операции с лексическим окружением
        print(n)

    return inner

fn = outer()   # fn = inner, так как функция outer возвращает функцию inner
# вызываем внутреннюю функцию inner
fn()    # 6
fn()    # 7
fn()    # 8
```

Здесь функция `outer` определяет локальную переменную `n` - это и есть лексическое окружение для внутренней функции:

Внутри функции outer определена внутренняя функция - локальная функция inner, которая обращается к своему лексическому окружению - переменной `n` - увеличивает ее значение на единицу и выводит на консоль.

Переменная `fn` и представляет собой замыкание, то есть объединяет две вещи: функцию и окружение, в котором функция была создана. И несмотря на то, что мы получили локальную функцию и можем ее вызывать вне ее окружающей функции, в которой она определена, тем не менее она запомнила свое лексическое окружение и может к нему обращаться и изменять, что мы увидим по консольному выводу.

### Применение параметров

Кроме внешних переменных к лексическому окружению также относятся параметры окружающей функции. Рассмотрим использование параметров:

```python
def multiply(n):
    def inner(m): return n * m 
    return inner 

fn = multiply(5)
print(fn(5))        # 25
print(fn(6))        # 30
print(fn(7))        # 35
```

Здесь внешняя функция - `multiply` возвращает функцию, которая принимает число и возвращает число.

Вызов функции `multiply()` возвращает локальную функцию inner.

Эта функция запоминает окружение, в котором она была создана, в частности, значение параметра `n`. Кроме того, сама принимает параметр и возвращает произведение параметров` n` и `m`.

В итоге при вызове функции `multiply` определяется переменная `fn`, которая получает локальную функцию `inner` и ее лексическое окружение - значение параметра `n`:

## Декораторы

Декораторы в Python представляют функцию, которая в качестве параметра получает функцию и в качестве результата также возвращает функцию. 
Декораторы позволяют модифицировать выполняемую функцию, значения ее  параметров и ее результат без изменения исходного кода этой функции.

Рассмотрим простейший пример:

```python
# определение функции декоратора
def select(input_func):    
    def output_func():      # определяем функцию, 
                            #которая будет выполняться 
                            #вместо оригинальной
        # перед выводом оригинальной функции выводим всякую звездочки
        print("*****************")  
        input_func()                # вызов оригинальной функции
        # после вывода оригинальной функции выводим всякую звездочки
        print("*****************")  
    return output_func     # возвращаем новую функцию

# определение оригинальной функции
@select         # применение декоратора select
def hello():
    print("Hello METANIT.COM")

# вызов оригинальной функции
hello()
#ouput: 
#*****************
#Hello METANIT.COM
#*****************
```

Вначале определяется собственно функция декоратора, которая в данном случае называется `select()`. В качестве параметра декоратор получает функцию (в данном случае параметр `input_func`), к которой этот декоратор будет применяться.

Результатом декоратора в данном случае является локальная функция `output_func`, в которой вызывается входная функция input_func. Для простоты здесь перед и после 
вызыва input_func для красоты просто выводим набор символов "#".

Далее определяется стандартная функция, к которой применяется декоратор - в данном случае это функция `hello`, которая просто выводит на консоль некоторую строку.

Для применения декоратора перед определением функции указывается символ `@`, после которого идет имя декоратора. То есть в данном случае к функции hello() применяется декоратор select().

Поскольку к этой функции применяется декоратор select, то в результате функциия hello передается в декоратор `select()` в качестве параметра `input_func`.

И поскольку декоратор возвращает новую функцию - output_func, то 
фактически в данном случае будет выполняться именно эта функция `output_func()`

В итоге мы получим следующий консольный вывод:

```bash
*****************
Hello METANIT.COM
*****************
```

### Получение параметров функции в декораторе

Декоратор может перехватывать передаваемые в функцию аргументы:

```python
# определение функции декоратора
def check(input_func):    
    def output_func(*args):
        name = args[0]
        age = args[1]           # получаем значение второго параметра
        if age < 0: age = 1     
        input_func(name, age)   # передаем функции значения для параметров
        #либо input_func(*args)
    return output_func

# определение оригинальной функции
@check
def print_person(name, age):
    print(f"Name: {name}  Age: {age}")

# вызов оригинальной функции
print_person("Tom", 38)
print_person("Bob", -5)
```

Здесь функция `print_person()` принимает два параметра: name (имя) и age (возраст). К этой функции применяется декоратор `check()`

В декораторе `check` возвращается локальная функция `output_func()`, которая принимает некоторый набор значений в виде параметра `*args` - это те 
значения, которые передаются в оригинальную функцию, к которой применяется декоратор. То есть в данном случае `*args` будет содержать значения параметров name и age.

args фактически представляет набор значений, и, используя индексы, мы 
можем получить значения параметров по позиции и что-то с ними сделать. 
Так, здесь, если значение возраста меньше 0, 
то устанавливаем 1. Затем передаем эти значения в вызов функции.

## match

Начиная с версии 3.10 в языке Python появилась такая функциональность как pattern matching (сопоставление шаблонов). Pattern matching представляет применение конструкции match,  которая позволяет сопоставить выражение с некоторым шаблоном. И если выражение соответствует шаблону, то выполняются определенные действия. match также позволяет извлечь данные из составных типов и применить действия к различным частям объектов.

Конструкция `match` имеет следующее формальное определение:

```python
match выражение:
    case шаблон_1:
        действие_1
    case шаблон_2:
        действие_2
    ................
    case шаблон_N:
        действие_N
    case _:
        действие_по_умолчанию
```

также можно определить блок case, который позволяет сравнивать сразу с 
несколькими знечениями. В этом случае значения разделяются вертикальной 
чертой:

```python
def print_hello(language):
    match language:
        case "russian":
            print("Привет")
        case "american english" | "british english" | "english":
            print("Hello")
        case _:
            print("Undefined")


print_hello("english")              # Hello
print_hello("american english")     # Hello
print_hello("spanish")              # Undefined
```

## строки

### объявление строки

```python
message = "Hello World!"
print(message)  # Hello World!

name = 'Tom'
print(name)  # Tom
```

Если строка длинная, ее можно разбить на части и разместить их на разных строках кода. В этом случае вся строка заключается в круглые скобки, а ее отдельные части - в кавычки:

```python
text = ("Laudate omnes gentes laudate "
        "Magnificat in secula ")
print(text)
```

Если же мы хотим определить многострочный текст, то такой текст заключается в тройные двойные или одинарные кавычки:

```python
'''
Это комментарий
'''
text = '''Laudate omnes gentes laudate
Magnificat in secula
Et anima mea laudate
Magnificat in secula 
'''
print(text)
```

При использовани тройных одинарных кавычек не стоит путать их с 
комментариями: если текст в тройных одинарных кавычках присваивается 
переменной, то это строка, а не комментарий.

### управляющие последовательности в строке

Строка может содержать ряд специальных символов - управляющих 
последовательностей или escape-последовательности. Некоторые из них:

- \: позволяет добавить внутрь строки слеш
- \': позволяет добавить внутрь строки одинарную кавычку
- \": позволяет добавить внутрь строки двойную кавычку
- \n: осуществляет переход на новую строку
- \t: добавляет табуляцию (4 отступа)

### f-строки

Python позволяет встравивать в строку значения других переменных. Для этого внутри строки переменные размещаются в фигурных скобках {}, а перед всей строкой ставится символ f: В данном случае на место {userName} будет вставляться значение переменной userName. Аналогично на вместо {userAge} будет вставляться значение переменной userAge.

```python
userName = "Tom"
userAge = 37
user = f"name: {userName}  age: {userAge}"
print(user)   # name: Tom  age: 37
```

### Обращение к символам строки

И мы можем обратиться к отдельным символам строки по индексу в квадратных скобках:

```python
string = "hello world"
c0 = string[0]  # h
print(c0)
c6 = string[6]  # w
print(c6)

c11 = string[11]  # ошибка IndexError: string index out of range
print(c11)
```

Индексация начинается с нуля, поэтому первый символ строки будет 
иметь индекс 0. А если мы попытаемся обратиться к индексу, которого нет в
 строке, то мы получим исключение IndexError. Например, в случае выше длина строки 11 символов, поэтому ее символы будут иметь индексы от 0 до 10.

Чтобы получить доступ к символам, начиная с конца строки, можно использовать отрицательные индексы. Так, индекс -1 будет представлять последний символ, а -2 - предпоследний символ и так далее:

```python
string = "hello world"
c1 = string[-1]  # d
print(c1)
c5 = string[-5]  # w
print(c5)
```

### Перебор строки

С помощью цикла for можно перебрать все символы строки:

```python
string = "hello world"
for char in string:
    print(char)
```

### Получение подстроки

При необходимости мы можем получить из строки не только отдельные 
символы, но и подстроку. Для этого используется следующий синтаксис:

- `string[:end]`: eизвлекается последовательность символов начиная с 0-го индекса по индекс end (не включая)

- `string[start:end]`: извлекается последовательность символов начиная с индекса start по индекс end (не включая)

- `string[start:end:step]`: извлекается последовательность символов начиная с индекса start по индекс end (не включая) через шаг step

Используем все варианты получения подстроки:

```python
string = "hello world"

# с 0 до 5 индекса
sub_string1 = string[:5]
print(sub_string1)      # hello

# со 2 до 5 индекса
sub_string2 = string[2:5]
print(sub_string2)      # llo

# с 2 по 9 индекса через один символ
sub_string3 = string[2:9:2]
print(sub_string3)      # lowr
```

### Объединение строк

Одной из самых распространенных операций со строками является их 
объединение или конкатенация. Для объединения строк применяется операция
 сложения:

```python
name = "Tom"
age = 33
info = "Name: " + name + " Age: " + str(age)
print(info)  # Name: Tom Age: 33
```

### Повторение строки

Для повторения строки определенное количество раз применяется операция умножения:

```python
print("a" * 3)  # aaa
print("he" * 4)  # hehehehe
```

### Сравнение строк

Особо следует сказать о сравнении строк. При сравнении строк 
принимается во внимание символы и их регистр. Так, цифровой символ 
условно меньше, чем любой алфавитный символ. Алфавитный символ в верхнем регистре условно меньше, чем алфавитные символы в нижнем регистре. Например:

```python
str1 = "1a"
str2 = "aa"
str3 = "Aa"
print(str1 > str2)  # False, так как первый символ в str1 - цифра
print(str2 > str3)  # True, так как первый символ в str2 - в нижнем регистре
```

Поэтому строка "1a" условно меньше, чем строка "aa". Вначале 
сравнение идет по первому символу. Если начальные символы обоих строк 
представляют цифры, то 
меньшей считается меньшая цифра, например, "1a" меньше, чем "2a".

Если начальные символы представляют алфавитные символы в одном и том 
же регистре, то смотрят по алфавиту. Так, "aa" меньше, чем "ba", а "ba" 
меньше, чем "ca".

Если первые символы одинаковые, в расчет берутся вторые символы при их наличии.

Зависимость от регистра не всегда желательна, так как по сути мы 
имеем дело с одинаковыми строками. В этом случае перед сравнением мы 
можем 
привести обе строки к одному из регистров.

Функция `lower()` приводит строку к нижнему регистру, а функция `upper()` - к верхнему.

```python
str1 = "Tom"
str2 = "tom"
print(str1 == str2)  # False - строки не равны

print(str1.lower() == str2.lower())  # True
```

### Функции ord и len

Поскольку строка содержит символы Unicode, то с помощью функции `ord()` мы можем получить числовое значение для символа в кодировке Unicode:

```python
print(ord("A"))     # 65
```

Для получения длины строки можно использовать функцию `len()`:

```python
string = "hello world"
length = len(string)
print(length)   # 11
```

### Поиск в строке

С помощью выражения `term in string` можно найти подстроку term в строке string. Если подстрока найдена, то выражение вернет значение `True`, иначе возвращается значение `False`:

```python
string = "hello world"
exist = "hello" in string
print(exist)    # True

exist = "sword" in string
print(exist)    # False
```

## with - as

The following code:

```python
with EXPRESSION as TARGET:
    SUITE
```

is semantically equivalent to:

```python
manager = (EXPRESSION)
enter = type(manager).__enter__
exit = type(manager).__exit__
value = enter(manager)
hit_except = False

try:
 TARGET = value
 SUITE
except:
 hit_except = True
 if not exit(manager, *sys.exc_info()):
     raise
finally:
 if not hit_except:
     exit(manager, None, None, None)
```

Позволяет взаимодействовать с объектом, возвращемым `EXPRESSION` через 'ссылку' `TARGET`, правильно передает и удаляет объект (вызывает деструктор `__exit__`)

> `With as` это конструкция, которая способна выполниться 
> сто процентов. Что это означает? Если при работе с файлами мы используем
>  метод open, то дополнительно нам необходимо еще и закрывать файл, иначе
>  это чревато последствиями.

> При работе с `With as` мы можем быть уверены в том, что файл точно будет закрыт, даже в случае неправильного выполнения функции.

> ```python
> with open('test.txt', 'wt', encoding='utf-8') as inFile: # Открытие файла
>    words = input() # Получение данных от пользователя
>     inFile.write (words) # Запись данных
> ```

> Также эта конструкция удобна тем, что вам не надо помнить про закрытие файла, так > как это выполняется автоматически.
> 
> [Что такое with as в Python? Онлайн справочник на itProger](https://itproger.com/spravka/python/with-as)

## Оператор in

Оператор in возвращает `True` если в некотором наборе значений есть определенное значение. Он имеет следующую форму:

```python
значение in набор_значений
```

Например, строка представляет набор символов. И с помощью оператора `in` мы можем проверить, есть ли в ней какая-нибудь подстрока:

```python
message = "hello world!"
hello = "hello"
print(hello in message)  # True - подстрока hello есть в строке "hello world!"

gold = "gold"
print(gold in message)  # False - подстроки "gold" нет в строке "hello world!"
```

Если нам надо наоборот проверить, нет ли в наборе значений 
какого-либо значения, то мы може использовать модификацию оператора - `not in`. 
Она возвращает `True`, если в наборе значений НЕТ определенного значения:

```python
message = "hello world!"
hello = "hello"
print(hello not in message)  # False

gold = "gold"
print(gold not in message)  # True
```

# ООП python

## Создание класса / объекта

Класс определяется с помощью ключевого слова `class`:

```python
class название_класса:
    атрибуты_класса
    методы_класса
```

Для создания объекта применяется специальная функция - конструктор, которая называется по имени класса и которая возвращает объект класса.

Пример:

```python
class Person:
    pass

tom = Person()      # определение объекта tom
```

## Методы классов

Методы класса фактически представляют функции, которые определенны внутри класса и которые определяют его поведение.При определении методов любого класса следует учитывать, что все они должны принимать в качестве первого параметра ссылку на текущий объект, который согласно условностям называется `self`. Через эту ссылку внутри класса мы можем обратиться к функциональности текущего объекта. Но при самом вызове метода этот параметр не учитывается.

Если метод должен принимать другие параметры, то они определяются после параметра `self`, и при вызове подобного метода для них необходимо передать значения

 Например, определим класс Person с одним методом:

```python
class Person:       # определение класса Person
     def say_hello(self):
        print("Hello")

tom = Person()
tom.say_hello()    # Hello
```

## self

Через ключевое слово self можно обращаться внутри класса к функциональности текущего объекта:

```python
self.атрибут    # обращение к атрибуту
self.метод      # обращение к методу
```

Так же при помощи `self` в конструкторе можно объявить атрибут (поле) класса.

И вообще атрибуты (поля) класса можно генерить прямо в рантайме просто обратившись к ним (классный способ выстрелить себе в ногу)

## Конструкторы (`__init__`)

Для создания объекта класса используется конструктор. Так, выше когда мы создавали объекты класса Person, мы использовали конструктор по умолчанию, который не принимает параметров и который неявно имеют все классы:

Однако мы можем явным образом определить в классах конструктор с помощью специального метода, который называется `__init__()` (по два прочерка с каждой стороны). К примеру, изменим класс Person, добавив в него конструктор:

```python
class Person:
    # конструктор
    def __init__(self):
        print("Создание объекта Person")

    def say_hello(self):
        print("Hello")


tom = Person()      # Создание объекта Person
tom.say_hello()     # Hello
```

## Инкапсуляция, атрибуты и свойства

По умолчанию атрибуты в классах являются общедоступными, а это значит, что из любого места программы мы можем получить атрибут объекта и изменить его. 

Касательно инкапсуляции непосредственно в языке программирования Python скрыть атрибуты класса можно сделав их приватными или закрытыми и ограничив доступ к ним через специальные методы, которые еще называются свойствами.

Изменим выше определенный класс, определив в нем свойства:

```python
class Person:
    def __init__(self, name):
        self.__name = name  # устанавливаем имя
        self.__age = 1  # устанавливаем возраст

    def set_age(self, age):
        if 1 < age < 110:
            self.__age = age
        else:
            print("Недопустимый возраст")

    def get_age(self):
        return self.__age

    def get_name(self):
        return self.__name

    def display_info(self):
        print(f"Имя: {self.__name}\tВозраст: {self.__age}")


tom = Person("Tom")
tom.display_info()  # Имя: Tom  Возраст: 1
tom.set_age(-3486)  # Недопустимый возраст
tom.set_age(25)
tom.display_info()  # Имя: Tom  Возраст: 25
```

Для создания приватного атрибута в начале его наименования ставится двойной прочерк: `self.__name`. К такому атрибуту мы сможем обратиться только из того же класса. Но не сможем обратиться вне этого класса.

А попытка получить его значение приведет к ошибке выполнения (если ранее не была определена переменная `__age`).

### Аннотации свойств

Выше мы рассмотрели, как создавать свойства. Но Python имеет также еще один - более элегантный способ определения свойств. Этот способ предполагает использование аннотаций, которые предваряются символом `@`.

Для создания свойства-геттера над свойством ставится аннотация `@property`.

Для создания свойства-сеттера над свойством устанавливается аннотация `имя_свойства_геттера.setter`.

Перепишем класс Person с использованием аннотаций:

```python
class Person:
    def __init__(self, name):
        self.__name = name  # устанавливаем имя
        self.__age = 1  # устанавливаем возраст

    @property
    def age(self):
        return self.__age

    @age.setter
    def age(self, age):
        if 1 < age < 110:
            self.__age = age
        else:
            print("Недопустимый возраст")

    @property
    def name(self):
        return self.__name

    def display_info(self):
        print(f"Имя: {self.__name}\tВозраст: {self.__age}")


tom = Person("Tom")

tom.display_info()  # Имя: Tom  Возраст: 1
tom.age = -3486  # Недопустимый возраст
print(tom.age)  # 1
tom.age = 36
tom.display_info()
```

Во-первых, стоит обратить внимание, что свойство-сеттер определяется после свойства-геттера.

Во-вторых, и сеттер, и геттер называются одинаково - `age`. И поскольку геттер называется `age`, то над сеттером устанавливается аннотация `@age.setter`.

После этого, что к геттеру, что к сеттеру, мы обращаемся через выражение `tom.age`.

## Наследование

Ключевыми понятиями наследования являются подкласс и суперкласс. Подкласс наследует от суперкласса все публичные атрибуты и методы. Суперкласс еще называется базовым (base class) или родительским (parent class), а подкласс - производным (derived class) или дочерним (child class).

Синтаксис для наследования классов выглядит следующим образом:

```python
class подкласс (суперкласс):
    методы_подкласса
```

возможно множественное наследование, в таком случае суперклассы перечисляют через запятую

## Атрибуты класса

Кроме атрибутов объектов в классе можно определять атрибуты классов. Подобные атрибуты определяются в виде переменных уровня класса. Например:

```python
class Person:
     type = "Person"
     description = "Describes a person"
 
 
print(Person.type)          # Person
print(Person.description)   # Describes a person
 
Person.type = "Class Person"
print(Person.type)          # Class Person
```

Здесь в классе `Person` определено два атрибута: `type`, который хранит имя класса, и `description`, который хранит описание класса.

Для обращения к атрибутам класса мы можем использовать имя класса, например: `Person.type`, и, как и атрибуты объекта, мы можем получать и изменять их значения.

Подобные атрибуты являются общими для всех объектов класса:

```python
class Person:
     type = "Person"
     def __init__(self, name):
         self.name = name
 
 
tom = Person("Tom")
bob = Person("Bob")
print(tom.type)     # Person
print(bob.type)     # Person
 
# изменим атрибут класса
Person.type = "Class Person"
print(tom.type)     # Class Person
print(bob.type)     # Class Person
```

Атрибут объекта "главнее" атрибута класса, то есть если для какого-то объекта задан атрибут совпадающий по имени с атрибутом класса - при обращении python вернет атрибут класса

## Статические методы

Кроме обычных методов класс может определять статические методы. Такие методы предваряются аннотацией `@staticmethod` и относятся в целом к классу. Статические методы обычно определяют поведение, которое не зависит от конкретного объекта:

```python
class Person:
    __type = "Person"
 
    @staticmethod
    def print_type():
        print(Person.__type)
 
 
Person.print_type()     # Person - обращение к статическому методу через имя класса
 
tom = Person()
tom.print_type()     # Person - обращение к статическому методу через имя объекта
```

## Класс object.

Начиная с 3-й версии в языке программирования Python все классы неявно имеют один общий суперкласс - `object` и все классы по умолчанию наследуют его методы.

Одним из наиболее используемых методов класса object является метод `__str__()`. Когда необходимо получить строковое представление объекта или вывести объект в виде строки, то Python как раз вызывает этот метод. И при определении класса хорошей практикой считается переопределение этого метода.

К примеру, возьмем класс Person и выведем его строковое представление:

```python
class Person:
    def __init__(self, name, age):
        self.name = name  # устанавливаем имя
        self.age = age  # устанавливаем возраст
 
    def display_info(self):
        print(f"Name: {self.name}  Age: {self.age}")
 
 
tom = Person("Tom", 23)
print(tom)
```

При запуске программа выведет что-то наподобие следующего:

```bash
<__main__.Person object at 0x10a63dc00>
```

Это не очень информативная информация об объекте. Мы, конечно, можем выйти из положения, определив в классе `Person` дополнительный метод, который выводит данные объекта - в примере выше это метод `display_info`.

Но есть и другой выход - определим в классе Person метод `__str__()` (по два подчеркивания с каждой стороны):

```python
class Person:
    def __init__(self, name, age):
        self.name = name  # устанавливаем имя
        self.age = age  # устанавливаем возраст
 
    def display_info(self):
        print(self)
        # print(self.__str__())     # или так
 
    def __str__(self):
        return f"Name: {self.name}  Age: {self.age}"
 
 
tom = Person("Tom", 23)
print(tom)      # Name: Tom  Age: 23
tom.display_info()  # Name: Tom  Age: 23

```

Метод `__str__` должен возвращать строку. И в данном случае мы возвращаем базовую информацию о человеке. Если нам потребуется использовать эту информацию в других методах класса, то мы можем использовать выражение `self.__str__()`

И теперь консольный вывод будет другим:

```bash
Name: Tom  Age: 23
Name: Tom  Age: 23
```
