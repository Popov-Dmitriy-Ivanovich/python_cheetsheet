# #TODO

match (дописать полностью когда появятся словари)??

regex

строки

with

as, in, not, 

file in/out

args?

date/time

# Функциональный  python

## Область видимости переменных

### Скрытие переменных

локальная переменная перекрывает глобальную (при ее изменении будет меняться локально созданный объект)  

### global

Если же мы хотим изменить в локальной функции глобальную переменную, а не определить локальную, то необходимо использовать ключевое слово global:  

```python
name = "Tom"  

def say_hi():  
    global  name  
    name = "Bob"        # изменяем значение глобальной переменной  
    print("Hello", name)  

say_hi()    # Hello Bob  
```

### nonlocal

Выражение nonlocal прикрепляет идентификатор к переменной из ближайщего окружающего контекста (за исключением глобального контекста). Обычно nonlocal применяется во вложенных функциях, когда надо прикрепить идентификатор за переменной или параметром окружающей внешней функции. Рассмотрим ситуацию, где это выражение может пригодиться:  

```python
def outer():  # внешняя функция
       n = 5
    def inner():    # вложенная функция
        n = 25 #создаваться новая переменная n, 
                #которая скроет переменную n из окружающей внешней
                # функции outer и получит значение 25
        print(n)
    inner()     # 25
    print(n)

outer()     # 5 
# 25    - inner
# 5     - outer
```

```python
def outer():  # внешняя функция
n = 5

    def inner():    # вложенная функция
        nonlocal n  # указываем, что n - это переменная из окружающей
                    # функции присваиваем значение 25 outer::n
        n = 25
        print(n)

    inner()     # 25
    print(n)


outer()
# 25 25
```

## Лямбда-выражения

Лямбда-выражения в языке Python представляют небольшие анонимные функции, которые определяются с помощью оператора lambda. Формальное определение лямбда-выражения:

```python
lambda [параметры] : инструкция
```

```python
    message = lambda: print("hello") 
    message() # output: hello
```

```python
sum = lambda a, b: a + b 
print(sum(4, 5))    # 9
```

lambda-выражения можно так же передавать в качестве параметров функции и (или) возвращать из функции (return)

## Замыкания

**<u>Замыкание</u>** (closure) представляет функцию, которая запоминает свое лексическое окружение даже в том случае, когда она выполняется вне своей области видимости.

Технически замыкание включает три компонента:

- внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные и параметры - лексическое окружение

- переменные и параметры (лексическое окружение), которые определены во внешней функции

- вложенная функция, которая использует переменные и параметры внешней функции

Для определения замыканий в Python применяются локальные функции:

```python
def outer():        # внешняя функция
    n = 5           # лексическое окружение - локальная переменная
    def inner():      # локальная функция
        nonlocal n
        n += 1        # операции с лексическим окружением
        print(n)

    return inner

fn = outer()   # fn = inner, так как функция outer возвращает функцию inner
# вызываем внутреннюю функцию inner
fn()    # 6
fn()    # 7
fn()    # 8
```

Здесь функция `outer` определяет локальную переменную n - это и есть лексическое окружение для внутренней функции:

Внутри функции outer определена внутренняя функция - локальная функция inner, которая обращается к своему лексическому окружению - переменной n - увеличивает ее значение на единицу и выводит на консоль.

Переменная `fn` и представляет собой замыкание, то есть объединяет две вещи: функцию и окружение, в котором функция была создана. И несмотря на то, что мы получили локальную функцию и можем ее вызывать вне ее окружающей функции, в которой она определена, тем не менее она запомнила свое лексическое окружение и может к нему обращаться и изменять, что мы увидим по консольному выводу.

### Применение параметров

Кроме внешних переменных к лексическому окружению также относятся параметры окружающей функции. Рассмотрим использование параметров:

```python
def multiply(n):
    def inner(m): return n * m 
    return inner 

fn = multiply(5)
print(fn(5))        # 25
print(fn(6))        # 30
print(fn(7))        # 35
```

Здесь внешняя функция - multiply возвращает функцию, которая принимает число и возвращает число.

Вызов функции `multiply()` возвращает локальную функцию inner.

Эта функция запоминает окружение, в котором она была создана, в частности, значение параметра n. Кроме того, сама принимает параметр и возвращает произведение параметров n и m.

В итоге при вызове функции multiply определяется переменная fn, которая получает локальную функцию inner и ее лексическое окружение - значение параметра n:

## Декораторы

Декораторы в Python представляют функцию, которая в качестве параметра получает функцию и в качестве результата также возвращает функцию. 
Декораторы позволяют модифицировать выполняемую функцию, значения ее  параметров и ее результат без изменения исходного кода этой функции.

Рассмотрим простейший пример:

```python
# определение функции декоратора
def select(input_func):    
    def output_func():      # определяем функцию, 
                            #которая будет выполняться 
                            #вместо оригинальной
        # перед выводом оригинальной функции выводим всякую звездочки
        print("*****************")  
        input_func()                # вызов оригинальной функции
        # после вывода оригинальной функции выводим всякую звездочки
        print("*****************")  
    return output_func     # возвращаем новую функцию

# определение оригинальной функции
@select         # применение декоратора select
def hello():
    print("Hello METANIT.COM")

# вызов оригинальной функции
hello()
#ouput: 
#*****************
#Hello METANIT.COM
#*****************
```

Вначале определяется собственно функция декоратора, которая в данном случае называется `select()`. В качестве параметра декоратор получает функцию (в данном случае параметр `input_func`), к которой этот декоратор будет применяться.

Результатом декоратора в данном случае является локальная функция `output_func`, в которой вызывается входная функция input_func. Для простоты здесь перед и после 
вызыва input_func для красоты просто выводим набор символов "#".

Далее определяется стандартная функция, к которой применяется декоратор - в данном случае это функция `hello`, которая просто выводит на консоль некоторую строку.

Для применения декоратора перед определением функции указывается символ `@`, после которого идет имя декоратора. То есть в данном случае к функции hello() применяется декоратор select().

Поскольку к этой функции применяется декоратор select, то в результате функциия hello передается в декоратор `select()` в качестве параметра `input_func`.

И поскольку декоратор возвращает новую функцию - output_func, то 
фактически в данном случае будет выполняться именно эта функция `output_func()`

В итоге мы получим следующий консольный вывод:

```bash
*****************
Hello METANIT.COM
*****************
```

### Получение параметров функции в декораторе

Декоратор может перехватывать передаваемые в функцию аргументы:

```python
# определение функции декоратора
def check(input_func):    
    def output_func(*args):
        name = args[0]
        age = args[1]           # получаем значение второго параметра
        if age < 0: age = 1     
        input_func(name, age)   # передаем функции значения для параметров
        #либо input_func(*args)
    return output_func

# определение оригинальной функции
@check
def print_person(name, age):
    print(f"Name: {name}  Age: {age}")

# вызов оригинальной функции
print_person("Tom", 38)
print_person("Bob", -5)
```

Здесь функция `print_person()` принимает два параметра: name (имя) и age (возраст). К этой функции применяется декоратор `check()`

В декораторе `check` возвращается локальная функция `output_func()`, которая принимает некоторый набор значений в виде параметра `*args` - это те 
значения, которые передаются в оригинальную функцию, к которой применяется декоратор. То есть в данном случае `*args` будет содержать значения параметров name и age.

args фактически представляет набор значений, и, используя индексы, мы 
можем получить значения параметров по позиции и что-то с ними сделать. 
Так, здесь, если значение возраста меньше 0, 
то устанавливаем 1. Затем передаем эти значения в вызов функции.

## match

Начиная с версии 3.10 в языке Python появилась такая функциональность как pattern matching (сопоставление шаблонов). Pattern matching представляет применение конструкции match,  которая позволяет сопоставить выражение с некоторым шаблоном. И если выражение соответствует шаблону, то выполняются определенные действия. match также позволяет извлечь данные из составных типов и применить действия к различным частям объектов.

Конструкция match имеет следующее формальное определение:

```python
match выражение:
    case шаблон_1:
        действие_1
    case шаблон_2:
        действие_2
    ................
    case шаблон_N:
        действие_N
    case _:
        действие_по_умолчанию
```

также можно определить блок case, который позволяет сравнивать сразу с 
несколькими знечениями. В этом случае значения разделяются вертикальной 
чертой:

```python
def print_hello(language):
    match language:
        case "russian":
            print("Привет")
        case "american english" | "british english" | "english":
            print("Hello")
        case _:
            print("Undefined")


print_hello("english")              # Hello
print_hello("american english")     # Hello
print_hello("spanish")              # Undefined
```

## строки

### объявление строки

```python
message = "Hello World!"
print(message)  # Hello World!

name = 'Tom'
print(name)  # Tom
```

Если строка длинная, ее можно разбить на части и разместить их на разных строках кода. В этом случае вся строка заключается в круглые скобки, а ее отдельные части - в кавычки:

```python
text = ("Laudate omnes gentes laudate "
        "Magnificat in secula ")
print(text)
```

Если же мы хотим определить многострочный текст, то такой текст заключается в тройные двойные или одинарные кавычки:

```python
'''
Это комментарий
'''
text = '''Laudate omnes gentes laudate
Magnificat in secula
Et anima mea laudate
Magnificat in secula 
'''
print(text)
```

При использовани тройных одинарных кавычек не стоит путать их с 
комментариями: если текст в тройных одинарных кавычках присваивается 
переменной, то это строка, а не комментарий.

### управляющие последовательности в строке

Строка может содержать ряд специальных символов - управляющих 
последовательностей или escape-последовательности. Некоторые из них:

- \: позволяет добавить внутрь строки слеш
- \': позволяет добавить внутрь строки одинарную кавычку
- \": позволяет добавить внутрь строки двойную кавычку
- \n: осуществляет переход на новую строку
- \t: добавляет табуляцию (4 отступа)

### f-строки

Python позволяет встравивать в строку значения других переменных. Для этого внутри строки переменные размещаются в фигурных скобках {}, а перед всей строкой ставится символ f: В данном случае на место {userName} будет вставляться значение переменной userName. Аналогично на вместо {userAge} будет вставляться значение переменной userAge.

```python
userName = "Tom"
userAge = 37
user = f"name: {userName}  age: {userAge}"
print(user)   # name: Tom  age: 37
```

### Обращение к символам строки

И мы можем обратиться к отдельным символам строки по индексу в квадратных скобках:

```python
string = "hello world"
c0 = string[0]  # h
print(c0)
c6 = string[6]  # w
print(c6)
 
c11 = string[11]  # ошибка IndexError: string index out of range
print(c11)
```

Индексация начинается с нуля, поэтому первый символ строки будет 
иметь индекс 0. А если мы попытаемся обратиться к индексу, которого нет в
 строке, то мы получим исключение IndexError. Например, в случае выше длина строки 11 символов, поэтому ее символы будут иметь индексы от 0 до 10.

Чтобы получить доступ к символам, начиная с конца строки, можно использовать отрицательные индексы. Так, индекс -1 будет представлять последний символ, а -2 - предпоследний символ и так далее:

```python
string = "hello world"
c1 = string[-1]  # d
print(c1)
c5 = string[-5]  # w
print(c5)
```

### Перебор строки

С помощью цикла for можно перебрать все символы строки:

```python
string = "hello world"
for char in string:
    print(char)
```

### Получение подстроки

При необходимости мы можем получить из строки не только отдельные 
символы, но и подстроку. Для этого используется следующий синтаксис:

- `string[:end]`: извлекается последовательность символов начиная с 0-го индекса по индекс end (не включая)

- `string[start:end]`: извлекается последовательность символов начиная с индекса start по индекс end (не включая)

- `string[start:end:step]`: извлекается последовательность символов начиная с индекса start по индекс end (не включая) через шаг step

Используем все варианты получения подстроки:

```python
string = "hello world"
 
# с 0 до 5 индекса
sub_string1 = string[:5]
print(sub_string1)      # hello
 
# со 2 до 5 индекса
sub_string2 = string[2:5]
print(sub_string2)      # llo
 
# с 2 по 9 индекса через один символ
sub_string3 = string[2:9:2]
print(sub_string3)      # lowr
```

### Объединение строк

Одной из самых распространенных операций со строками является их 
объединение или конкатенация. Для объединения строк применяется операция
 сложения:

```python
name = "Tom"
age = 33
info = "Name: " + name + " Age: " + str(age)
print(info)  # Name: Tom Age: 33
```

### Повторение строки

Для повторения строки определенное количество раз применяется операция умножения:

```python
print("a" * 3)  # aaa
print("he" * 4)  # hehehehe
```


